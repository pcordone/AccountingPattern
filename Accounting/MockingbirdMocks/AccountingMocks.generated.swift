//
//  AccountingMocks.generated.swift
//  Accounting
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

@testable import Accounting
@testable import Mockingbird
import DataStructures
import Foundation
import Swift
import SwiftUI
import os.log

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AccountingEvent

public final class AccountingEventMock: Accounting.AccountingEvent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AccountingEventMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType, __file: StaticString = #file, __line: UInt = #line) -> AccountingEventMock {
      let mock: AccountingEventMock = AccountingEventMock(otherParty: `otherParty`, isProcessed: `isProcessed`, whenNoticed: `whenNoticed`, whenOccurred: `whenOccurred`, eventType: `eventType`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked isProcessed

  override public var `isProcessed`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getIsProcessed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setIsProcessed(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked whenNoticed

  override public var `whenNoticed`: Date? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Date?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Date?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWhenNoticed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?>(mock: self, invocation: invocation)
  }

  public func setWhenNoticed(_ newValue: @escaping @autoclosure () -> Date?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `findRule`()

  public override func `findRule`() -> Accounting.PostingRule {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`findRule`() -> Accounting.PostingRule", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Accounting.PostingRule {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Accounting.PostingRule)()
    }
  }

  public func `findRule`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Accounting.PostingRule, Accounting.PostingRule> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`findRule`() -> Accounting.PostingRule", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Accounting.PostingRule, Accounting.PostingRule>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType)

  public required override init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType) {
    super.init(otherParty: `otherParty`, isProcessed: `isProcessed`, whenNoticed: `whenNoticed`, whenOccurred: `whenOccurred`, eventType: `eventType`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType) ", arguments: [Mockingbird.ArgumentMatcher(`otherParty`), Mockingbird.ArgumentMatcher(`isProcessed`), Mockingbird.ArgumentMatcher(`whenNoticed`), Mockingbird.ArgumentMatcher(`whenOccurred`), Mockingbird.ArgumentMatcher(`eventType`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `process`()

  public override func `process`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`process`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `process`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`process`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Accounting.AccountingEvent` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.AccountingEvent.Type) -> AccountingEventMock.InitializerProxy.Type {
  return AccountingEventMock.InitializerProxy.self
}

// MARK: - Mocked EventType

public final class EventTypeMock: Accounting.EventType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EventTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`name`: String, __file: StaticString = #file, __line: UInt = #line) -> EventTypeMock {
      let mock: EventTypeMock = EventTypeMock(name: `name`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked name

  override public var `name`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getName() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public func setName(_ newValue: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`name`: String)

  public required override init(`name`: String) {
    super.init(name: `name`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`name`: String) ", arguments: [Mockingbird.ArgumentMatcher(`name`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Accounting.EventType` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.EventType.Type) -> EventTypeMock.InitializerProxy.Type {
  return EventTypeMock.InitializerProxy.self
}

// MARK: - Mocked Event

public final class EventMock: Accounting.Event, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EventMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked eventType

  public var `eventType`: Accounting.EventType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "eventType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Accounting.EventType)()
    }
  }

  public func getEventType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Accounting.EventType, Accounting.EventType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "eventType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Accounting.EventType, Accounting.EventType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked isProcessed

  public var `isProcessed`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getIsProcessed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setIsProcessed(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked whenNoticed

  public var `whenNoticed`: Date? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Date?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Date?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWhenNoticed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?>(mock: self, invocation: invocation)
  }

  public func setWhenNoticed(_ newValue: @escaping @autoclosure () -> Date?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked whenOccurred

  public var `whenOccurred`: Date {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenOccurred.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Date)()
    }
  }

  public func getWhenOccurred() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date, Date> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenOccurred.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date, Date>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Accounting.Event` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.Event.Protocol) -> EventMock.InitializerProxy.Type {
  return EventMock.InitializerProxy.self
}

// MARK: - Mocked MoneyEventTypes

public final class MoneyEventTypesMock: Accounting.MoneyEventTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MoneyEventTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`name`: String, __file: StaticString = #file, __line: UInt = #line) -> MoneyEventTypesMock {
      let mock: MoneyEventTypesMock = MoneyEventTypesMock(name: `name`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked name

  override public var `name`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getName() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public func setName(_ newValue: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`name`: String)

  public required override init(`name`: String) {
    super.init(name: `name`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`name`: String) ", arguments: [Mockingbird.ArgumentMatcher(`name`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Accounting.MoneyEventTypes` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.MoneyEventTypes.Type) -> MoneyEventTypesMock.InitializerProxy.Type {
  return MoneyEventTypesMock.InitializerProxy.self
}

// MARK: - Mocked MoneyEvent

public final class MoneyEventMock: Accounting.MoneyEvent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MoneyEventMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType, `amount`: Accounting.Money, __file: StaticString = #file, __line: UInt = #line) -> MoneyEventMock {
      let mock: MoneyEventMock = MoneyEventMock(otherParty: `otherParty`, isProcessed: `isProcessed`, whenNoticed: `whenNoticed`, whenOccurred: `whenOccurred`, eventType: `eventType`, amount: `amount`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked isProcessed

  override public var `isProcessed`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getIsProcessed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setIsProcessed(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isProcessed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked whenNoticed

  override public var `whenNoticed`: Date? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Date?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Date?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWhenNoticed() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Date?, Date?>(mock: self, invocation: invocation)
  }

  public func setWhenNoticed(_ newValue: @escaping @autoclosure () -> Date?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "whenNoticed.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Date?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `findRule`()

  public override func `findRule`() -> Accounting.PostingRule {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`findRule`() -> Accounting.PostingRule", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Accounting.PostingRule {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Accounting.PostingRule)()
    }
  }

  public func `findRule`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Accounting.PostingRule, Accounting.PostingRule> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`findRule`() -> Accounting.PostingRule", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Accounting.PostingRule, Accounting.PostingRule>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType, `amount`: Accounting.Money)

  public required override init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType, `amount`: Accounting.Money) {
    super.init(otherParty: `otherParty`, isProcessed: `isProcessed`, whenNoticed: `whenNoticed`, whenOccurred: `whenOccurred`, eventType: `eventType`, amount: `amount`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`otherParty`: Accounting.OtherParty, `isProcessed`: Bool, `whenNoticed`: Date?, `whenOccurred`: Date, `eventType`: Accounting.EventType, `amount`: Accounting.Money) ", arguments: [Mockingbird.ArgumentMatcher(`otherParty`), Mockingbird.ArgumentMatcher(`isProcessed`), Mockingbird.ArgumentMatcher(`whenNoticed`), Mockingbird.ArgumentMatcher(`whenOccurred`), Mockingbird.ArgumentMatcher(`eventType`), Mockingbird.ArgumentMatcher(`amount`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `process`()

  public override func `process`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`process`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `process`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`process`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Accounting.MoneyEvent` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.MoneyEvent.Type) -> MoneyEventMock.InitializerProxy.Type {
  return MoneyEventMock.InitializerProxy.self
}

// MARK: - Mocked NamedObject

public final class NamedObjectMock: Accounting.NamedObject, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NamedObjectMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked name

  public var `name`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getName() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public func setName(_ newValue: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "name.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Accounting.NamedObject` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.NamedObject.Protocol) -> NamedObjectMock.InitializerProxy.Type {
  return NamedObjectMock.InitializerProxy.self
}

// MARK: - Mocked PostingRule

public final class PostingRuleMock: Accounting.PostingRule, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Accounting"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      PostingRuleMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked entryType

  public var `entryType`: Accounting.EntryType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "entryType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Accounting.EntryType)()
    }
  }

  public func getEntryType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Accounting.EntryType, Accounting.EntryType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "entryType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Accounting.EntryType, Accounting.EntryType>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `processEvent`(_ `event`: Accounting.AccountingEvent, `withChartOfAccounts` `COA`: Accounting.ChartOfAccounts)

  public func `processEvent`(_ `event`: Accounting.AccountingEvent, `withChartOfAccounts` `COA`: Accounting.ChartOfAccounts) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processEvent`(_ `event`: Accounting.AccountingEvent, `withChartOfAccounts` `COA`: Accounting.ChartOfAccounts) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`event`), Mockingbird.ArgumentMatcher(`COA`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Accounting.AccountingEvent, Accounting.ChartOfAccounts) throws -> Void {
      try concreteImplementation(`event`, `COA`)
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `processEvent`(_ `event`: @escaping @autoclosure () -> Accounting.AccountingEvent, `withChartOfAccounts` `COA`: @escaping @autoclosure () -> Accounting.ChartOfAccounts) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Accounting.AccountingEvent, Accounting.ChartOfAccounts) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`event`), Mockingbird.resolve(`COA`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processEvent`(_ `event`: Accounting.AccountingEvent, `withChartOfAccounts` `COA`: Accounting.ChartOfAccounts) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Accounting.AccountingEvent, Accounting.ChartOfAccounts) throws -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Accounting.PostingRule` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Accounting.PostingRule.Protocol) -> PostingRuleMock {
  return PostingRuleMock(sourceLocation: SourceLocation(file, line))
}
